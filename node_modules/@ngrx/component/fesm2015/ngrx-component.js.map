{"version":3,"file":"ngrx-component.js","sources":["../modules/component/src/core/cd-aware/cd-aware_creator.ts","../modules/component/src/core/utils/has-zone.ts","../modules/component/src/core/cd-aware/creator_render.ts","../../modules/component/src/push/push.pipe.ts","../../modules/component/src/let/let.directive.ts","../src/reactive-component.module.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  EMPTY,\n  from,\n  isObservable,\n  NextObserver,\n  Observable,\n  ObservableInput,\n  Subject,\n  Subscribable,\n  Subscription,\n} from 'rxjs';\nimport {\n  catchError,\n  distinctUntilChanged,\n  switchMap,\n  tap,\n} from 'rxjs/operators';\n\nexport interface CdAware<U> extends Subscribable<U> {\n  nextPotentialObservable: (\n    value: ObservableInput<any> | null | undefined\n  ) => void;\n}\n\n/**\n * class CdAware\n *\n * @description\n * This abstract class holds all the shared logic for the push pipe and the let directive\n * responsible for change detection\n * If you extend this class you need to implement how the update of the rendered value happens.\n * Also custom behaviour is something you need to implement in the extending class\n */\nexport function createCdAware<U>(cfg: {\n  render: () => void;\n  resetContextObserver: NextObserver<void>;\n  updateViewContextObserver: NextObserver<U | undefined | null>;\n}): CdAware<U | undefined | null> {\n  const potentialObservablesSubject: Subject<\n    ObservableInput<U> | undefined | null\n  > = new Subject();\n  const observablesFromTemplate$: Observable<\n    ObservableInput<U> | undefined | null\n  > = potentialObservablesSubject.pipe(distinctUntilChanged());\n\n  const rendering$ = observablesFromTemplate$.pipe(\n    // Compose the observables from the template and the strategy\n    switchMap((observable$) => {\n      // If the passed observable is:\n      // - undefined - No value set\n      // - null - null passed directly or no value set over `async` pipe\n      if (observable$ == null) {\n        // Update the value to render_creator with null/undefined\n        cfg.updateViewContextObserver.next(observable$ as any);\n        // Render the view\n        cfg.render();\n        // Stop further processing\n        return EMPTY;\n      }\n\n      const ob$: Observable<U> = isObservable(observable$)\n        ? (observable$ as Observable<U>)\n        : from(observable$);\n\n      // If a new Observable arrives, reset the value to render_creator\n      // We do this because we don't know when the next value arrives and want to get rid of the old value\n      cfg.resetContextObserver.next();\n      cfg.render();\n\n      return (ob$ as Observable<U>).pipe(\n        distinctUntilChanged(),\n        tap(cfg.updateViewContextObserver),\n        tap(() => cfg.render()),\n        catchError((e) => {\n          return EMPTY;\n        })\n      );\n    })\n  );\n\n  return {\n    nextPotentialObservable(\n      value: ObservableInput<U> | undefined | null\n    ): void {\n      potentialObservablesSubject.next(value);\n    },\n    subscribe(): Subscription {\n      return rendering$.subscribe();\n    },\n  } as CdAware<U | undefined | null>;\n}\n","import { NgZone } from '@angular/core';\n\n/**\n * @description\n *\n * Determines if the application uses `NgZone` or `NgNoopZone` as ngZone service instance.\n *\n * The function can be just imported and used everywhere.\n *\n * ```ts\n * import { hasZone } from `utils/has-zone`;\n *\n * console.log(hasZone());\n * ```\n */\nexport function hasZone(z: NgZone): boolean {\n  return z instanceof NgZone;\n}\n","import { ChangeDetectorRef, NgZone } from '@angular/core';\n\nimport { hasZone } from '../utils/has-zone';\n\nexport interface RenderConfig {\n  ngZone: NgZone;\n  cdRef: ChangeDetectorRef;\n}\n\nexport function createRender<T>(config: RenderConfig): () => void {\n  function render() {\n    if (hasZone(config.ngZone)) {\n      config.cdRef.markForCheck();\n    } else {\n      config.cdRef.detectChanges();\n    }\n  }\n\n  return render;\n}\n","import {\n  ChangeDetectorRef,\n  NgZone,\n  OnDestroy,\n  Pipe,\n  PipeTransform,\n} from '@angular/core';\nimport { NextObserver, ObservableInput, Unsubscribable } from 'rxjs';\n\nimport { CdAware, createCdAware } from '../core/cd-aware/cd-aware_creator';\nimport { createRender } from '../core/cd-aware/creator_render';\n\n/**\n * @Pipe PushPipe\n *\n * @description\n *\n * The `ngrxPush` pipe serves as a drop-in replacement for the `async` pipe.\n * It contains intelligent handling of change detection to enable us\n * running in zone-full as well as zone-less mode without any changes to the code.\n *\n * The current way of binding an observable to the view looks like that:\n *  ```html\n *  {{observable$ | async}}\n * <ng-container *ngIf=\"observable$ | async as o\">{{o}}</ng-container>\n * <component [value]=\"observable$ | async\"></component>\n * ```\n *\n * The problem is `async` pipe just marks the component and all its ancestors as dirty.\n * It needs zone.js microtask queue to exhaust until `ApplicationRef.tick` is called to render_creator all dirty marked\n *     components.\n *\n * Heavy dynamic and interactive UIs suffer from zones change detection a lot and can\n * lean to bad performance or even unusable applications, but the `async` pipe does not work in zone-less mode.\n *\n * `ngrxPush` pipe solves that problem.\n *\n * Included Features:\n *  - Take observables or promises, retrieve their values and render_creator the value to the template\n *  - Handling null and undefined values in a clean unified/structured way\n *  - Triggers change-detection differently if `zone.js` is present or not (`detectChanges` or `markForCheck`)\n *  - Distinct same values in a row to increase performance\n *  - Coalescing of change detection calls to boost performance\n *\n * @usageNotes\n *\n * `ngrxPush` pipe solves that problem. It can be used like shown here:\n * ```html\n * {{observable$ | ngrxPush}}\n * <ng-container *ngIf=\"observable$ | ngrxPush as o\">{{o}}</ng-container>\n * <component [value]=\"observable$ | ngrxPush\"></component>\n * ```\n *\n * @publicApi\n */\n@Pipe({ name: 'ngrxPush', pure: false })\nexport class PushPipe<S> implements PipeTransform, OnDestroy {\n  private renderedValue: S | null | undefined;\n\n  private readonly subscription: Unsubscribable;\n  private readonly cdAware: CdAware<S | null | undefined>;\n  private readonly resetContextObserver: NextObserver<void> = {\n    next: () => (this.renderedValue = undefined),\n  };\n  private readonly updateViewContextObserver: NextObserver<\n    S | null | undefined\n  > = {\n    next: (value: S | null | undefined) => (this.renderedValue = value),\n  };\n\n  constructor(cdRef: ChangeDetectorRef, ngZone: NgZone) {\n    this.cdAware = createCdAware<S>({\n      render: createRender({ cdRef, ngZone }),\n      updateViewContextObserver: this.updateViewContextObserver,\n      resetContextObserver: this.resetContextObserver,\n    });\n    this.subscription = this.cdAware.subscribe();\n  }\n\n  transform<T>(potentialObservable: null): null;\n  transform<T>(potentialObservable: undefined): undefined;\n  transform<T>(potentialObservable: ObservableInput<T>): T | undefined;\n  transform<T>(\n    potentialObservable: ObservableInput<T> | null | undefined\n  ): T | null | undefined {\n    this.cdAware.nextPotentialObservable(potentialObservable);\n    return this.renderedValue as any;\n  }\n\n  ngOnDestroy(): void {\n    this.subscription.unsubscribe();\n  }\n}\n","import {\n  ChangeDetectorRef,\n  Directive,\n  Input,\n  NgZone,\n  OnDestroy,\n  TemplateRef,\n  ViewContainerRef,\n} from '@angular/core';\n\nimport { NextObserver, ObservableInput, Observer, Unsubscribable } from 'rxjs';\n\nimport { CdAware, createCdAware } from '../core/cd-aware/cd-aware_creator';\nimport { createRender } from '../core/cd-aware/creator_render';\n\nexport interface LetViewContext<T> {\n  // to enable `let` syntax we have to use $implicit (var; let v = var)\n  $implicit: T;\n  // to enable `as` syntax we have to assign the directives selector (var as v)\n  ngrxLet: T;\n  // set context var complete to true (var$; let e = $error)\n  $error: boolean;\n  // set context var complete to true (var$; let c = $complete)\n  $complete: boolean;\n}\n\n/**\n * @Directive LetDirective\n *\n * @description\n *\n * The `*ngrxLet` directive serves a convenient way of binding observables to a view context (a dom element scope).\n * It also helps with several internal processing under the hood.\n *\n * The current way of binding an observable to the view looks like that:\n * ```html\n * <ng-container *ngIf=\"observableNumber$ as n\">\n * <app-number [number]=\"n\">\n * </app-number>\n * <app-number-special [number]=\"n\">\n * </app-number-special>\n * </ng-container>\n *  ```\n *\n *  The problem is `*ngIf` is also interfering with rendering and in case of a `0` the component would be hidden\n *\n * Included Features:\n * - binding is always present. (`*ngIf=\"truthy$\"`)\n * - it takes away the multiple usages of the `async` or `ngrxPush` pipe\n * - a unified/structured way of handling null and undefined\n * - triggers change-detection differently if `zone.js` is present or not (`ChangeDetectorRef.detectChanges` or `ChangeDetectorRef.markForCheck`)\n * - triggers change-detection differently if ViewEngine or Ivy is present (`ChangeDetectorRef.detectChanges` or `ɵdetectChanges`)\n * - distinct same values in a row (distinctUntilChanged operator),\n *\n * @usageNotes\n *\n * The `*ngrxLet` directive take over several things and makes it more convenient and save to work with streams in the template\n * `<ng-container *ngrxLet=\"observableNumber$ as c\"></ng-container>`\n *\n * ```html\n * <ng-container *ngrxLet=\"observableNumber$ as n\">\n * <app-number [number]=\"n\">\n * </app-number>\n * </ng-container>\n *\n * <ng-container *ngrxLet=\"observableNumber$; let n\">\n * <app-number [number]=\"n\">\n * </app-number>\n * </ng-container>\n * ```\n *\n * In addition to that it provides us information from the whole observable context.\n * We can track the observables:\n * - next value\n * - error value\n * - complete state\n *\n * ```html\n * <ng-container *ngrxLet=\"observableNumber$; let n; let e = $error, let c = $complete\">\n * <app-number [number]=\"n\"  *ngIf=\"!e && !c\">\n * </app-number>\n * <ng-container *ngIf=\"e\">\n * There is an error: {{e}}\n * </ng-container>\n * <ng-container *ngIf=\"c\">\n * Observable completed: {{c}}\n * </ng-container>\n * </ng-container>\n * ```\n *\n * @publicApi\n */\n@Directive({ selector: '[ngrxLet]' })\nexport class LetDirective<U> implements OnDestroy {\n  private embeddedView: any;\n  private readonly ViewContext: LetViewContext<U | undefined | null> = {\n    $implicit: undefined,\n    ngrxLet: undefined,\n    $error: false,\n    $complete: false,\n  };\n\n  protected readonly subscription: Unsubscribable;\n  private readonly cdAware: CdAware<U | null | undefined>;\n  private readonly resetContextObserver: NextObserver<void> = {\n    next: () => {\n      // if not initialized no need to set undefined\n      if (this.embeddedView) {\n        this.ViewContext.$implicit = undefined;\n        this.ViewContext.ngrxLet = undefined;\n        this.ViewContext.$error = false;\n        this.ViewContext.$complete = false;\n      }\n    },\n  };\n  private readonly updateViewContextObserver: Observer<U | null | undefined> = {\n    next: (value: U | null | undefined) => {\n      // to have init lazy\n      if (!this.embeddedView) {\n        this.createEmbeddedView();\n      }\n      this.ViewContext.$implicit = value;\n      this.ViewContext.ngrxLet = value;\n    },\n    error: (error: Error) => {\n      // to have init lazy\n      if (!this.embeddedView) {\n        this.createEmbeddedView();\n      }\n      this.ViewContext.$error = true;\n    },\n    complete: () => {\n      // to have init lazy\n      if (!this.embeddedView) {\n        this.createEmbeddedView();\n      }\n      this.ViewContext.$complete = true;\n    },\n  };\n\n  static ngTemplateContextGuard<U>(\n    dir: LetDirective<U>,\n    ctx: unknown | null | undefined\n  ): ctx is LetViewContext<U> {\n    return true;\n  }\n\n  static ngTemplateGuard_ngrxLet: 'binding';\n\n  @Input()\n  set ngrxLet(potentialObservable: ObservableInput<U> | null | undefined) {\n    this.cdAware.nextPotentialObservable(potentialObservable);\n  }\n\n  constructor(\n    cdRef: ChangeDetectorRef,\n    ngZone: NgZone,\n    private readonly templateRef: TemplateRef<LetViewContext<U>>,\n    private readonly viewContainerRef: ViewContainerRef\n  ) {\n    this.cdAware = createCdAware<U>({\n      render: createRender({ cdRef, ngZone }),\n      resetContextObserver: this.resetContextObserver,\n      updateViewContextObserver: this.updateViewContextObserver,\n    });\n    this.subscription = this.cdAware.subscribe();\n  }\n\n  createEmbeddedView() {\n    this.embeddedView = this.viewContainerRef.createEmbeddedView(\n      this.templateRef,\n      this.ViewContext\n    );\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n    this.viewContainerRef.clear();\n  }\n}\n","import { NgModule } from '@angular/core';\n\nimport { LetDirective } from './let/let.directive';\nimport { PushPipe } from './push/push.pipe';\n\nconst DECLARATIONS = [LetDirective, PushPipe];\nconst EXPORTS = [DECLARATIONS];\n\n@NgModule({\n  declarations: [DECLARATIONS],\n  exports: [EXPORTS],\n})\nexport class ReactiveComponentModule {}\n"]}